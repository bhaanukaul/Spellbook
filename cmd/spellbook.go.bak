package cmd

import (
	"Spellbook/internal/Constants"
	"Spellbook/internal/Spell"
	"Spellbook/internal/Utils"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/blevesearch/bleve/v2"
	"github.com/gin-gonic/gin"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/urfave/cli/v2"
	"gopkg.in/ini.v1"
)

type RemoteSection struct {
	Alias       string `json:"alias"`
	Description string `json:"description"`
	Url         string `json:"url"`
}

func SyncRemoteSpellbook(c *cli.Context) error {
	alias := c.String("alias")
	log.Printf("alias: %s", alias)
	if alias != "" {
		SyncRemote(alias)
		return nil
	}
	config := GetServerConfig()
	cfg, err := ini.Load(config)
	if err != nil {
		Utils.Error("", err)
	}
	parent, err := cfg.GetSection(Constants.RemotesParent)
	if err != nil {
		Utils.Error("", err)
	}
	sections := parent.ChildSections()
	for _, s := range sections {
		SyncRemote(s.Name())
	}
	return nil
}

/*
Initial Server funcs
*/
var serverCmd = &cobra.Command{
	Use: "server",
}

var serverStartCmd = &cobra.Command{
	Use: "start",
	Run: StartServer,
}

func init() {
	rootCmd.AddCommand(serverCmd)
	serverCmd.AddCommand(serverStartCmd)
}

func StartServer(c *cobra.Command, args []string) {
	router := gin.Default()

	api := router.Group("/api")
	{
		api.GET("/spell/:id", getSpell)
		api.GET("/spells", getAllSpells)
		api.POST("/spell", createSpell)
		api.PATCH("/spell/:id", updateSpell)
		// api.POST("/spellbook", AddRemoteSpellbookApi)
		// api.GET("/spellbooks", GetAllSpellbooks)
	}
	router.GET("/ping", ping)
	// configFile := GetServerConfig()
	// port := Utils.GetKVFromConfig(configFile, "http_port", "server")
	router.Run(viper.GetString("SERVER_PORT"))
	return
}

func SetupServer(c *cli.Context) error {
	var serverHome string
	var err error
	serverHome, err = os.Getwd()
	port := c.String("port")
	if err != nil {
		log.Fatal(err)
		return nil
	}

	configFileName := "spellbook-server.ini"
	spellbookConfigDir := GetServerConfigDir(serverHome)
	err = os.MkdirAll(spellbookConfigDir, os.ModePerm)
	if err != nil {
		Utils.Error("Error", err)
	}

	spellbookRemotesDir := GetServerRemotesDir(serverHome)
	err = os.MkdirAll(spellbookRemotesDir, os.ModePerm)
	if err != nil {
		Utils.Error("Error", err)
	}

	spellbookConfigFile := spellbookConfigDir + "/" + configFileName
	emptyConfig, err := os.Create(spellbookConfigFile)

	if err != nil {
		Utils.Error("Error", err)
	}
	emptyConfig.Close()
	Utils.AddKVToConfig(spellbookConfigFile, "http_port", port, "server")
	mapping := bleve.NewIndexMapping()
	index_name := "Spellbook.bleve"
	Utils.AddKVToConfig(spellbookConfigFile, "index", index_name, "server")
	_, err = bleve.New(index_name, mapping)
	if err != nil {
		Utils.Error("Error", err)
	}
	return nil
}

/*
Server Management
*/

func AddRemoteSpellbookCli(c *cli.Context) error {
	if c.Args().Len() != 3 {
		Utils.Error("\"spellbook-server add\" requires 2 arguments.", nil)
	}
	alias := c.String("alias")
	spellbookUrl := c.String("url")
	description := c.String("description")
	splitSpellbook := strings.Split(spellbookUrl, ".")
	extension := splitSpellbook[len(splitSpellbook)-1]
	if extension != "json" {
		Utils.Error("Remote needs to be a json file.", nil)
	}

	AddRemoteServer(alias, spellbookUrl, description)
	return nil
}

func getAllSpellbooks(c *gin.Context) {
	cd := GetServerConfig()

	cfg, err := ini.Load(cd)
	if err != nil {
		Utils.Error("Cannot load config.", err)
	}

	names := cfg.ChildSections("remotes")
	var returnSb []RemoteSection
	for _, n := range names {
		toAdd := RemoteSection{
			Alias: n.Key("alias").String(), Description: n.Key("description").String(), Url: n.Key("url").String(),
		}
		returnSb = append(returnSb, toAdd)
	}
	c.JSON(http.StatusOK, returnSb)
}

func addRemoteSpellbookApi(c *gin.Context) {
	var remoteSection RemoteSection
	if err := c.BindJSON(&remoteSection); err != nil {
		Utils.Error("", err)
		return
	}

	AddRemoteServer(remoteSection.Alias, remoteSection.Url, remoteSection.Description)
	c.JSON(http.StatusCreated, remoteSection)
}

func updateSpell(c *gin.Context) {
	var spellToUpdate Spell.Spell
	if err := c.BindJSON(&spellToUpdate); err != nil {
		c.JSON(http.StatusBadRequest, "Invalid Request Body")
		return
	}
	spell_id_param := c.Param("id")
	spellToUpdate.ID = spell_id_param
	index := GetBleveIndex()
	_, err := Spell.CreateSpell(spellToUpdate, index)
	if err != nil {

		c.JSON(http.StatusInternalServerError, err)
	}
	// Spell.UpdateSpell(spell_id_param, spellToUpdate, index)
	index.Close()
}

func createSpell(c *gin.Context) {

	var newSpell Spell.Spell
	if err := c.BindJSON(&newSpell); err != nil {
		c.JSON(http.StatusBadRequest, "Invalid Request Body")
		return
	}

	log.Printf("From POST CreateSpell: %s, %s, %s, %s", newSpell.Language, newSpell.Contents, newSpell.Description, newSpell.Tags)
	index := GetBleveIndex()
	spell, err := Spell.CreateSpell(newSpell, index)
	index.Close()
	if err != nil {
		c.JSON(http.StatusInternalServerError, err)
		return
	}

	c.JSON(http.StatusCreated, spell)

}

func getSpell(c *gin.Context) {
	spell_id_param := c.Param("id")
	index := GetBleveIndex()
	searchResult, err := Spell.GetSpellByID(spell_id_param, index)
	index.Close()

	if err != nil {
		panic(err)
	}

	if searchResult.Hits.Len() == 0 {
		c.JSON(http.StatusNotFound, "Spell Not Found")
	} else {
		var spell Spell.Spell
		result := searchResult.Hits[0].Fields
		spell.ID = result["id"].(string)
		spell.Description = result["description"].(string)
		spell.Language = result["language"].(string)
		spell.Contents = result["contents"].(string)
		spell.Tags = result["tags"].(string)
		spell.Author = result["author"].(string)

		// c.BindJSON(&result)
		c.JSON(http.StatusOK, result)
	}
}

func getAllSpells(c *gin.Context) {
	qf := c.Query("field")
	qfv := c.Query("value")
	log.Printf("Query params: %s, %s", qf, qfv)
	index := GetBleveIndex()

	if qf != "" && qfv != "" {
		log.Printf("Using query parameters %s, %s", qf, qfv)
		var searchResult *bleve.SearchResult
		var err error
		var spells []Spell.Spell
		if qf == "tags" {
			searchResult, err = Spell.FindSpellsByTag(qfv, index)
		} else if qf == "description" {
			searchResult, err = Spell.FindSpellsByDescription(qfv, index)
		}

		if err != nil {
			Utils.Error(fmt.Sprintf("Error searching %s for %s", qf, qfv), err)
			c.JSON(http.StatusInternalServerError, err)
		}

		for _, doc := range searchResult.Hits {
			spell := Spell.Spell{
				ID:          doc.Fields["id"].(string),
				Description: doc.Fields["description"].(string),
				Language:    doc.Fields["language"].(string),
				Contents:    doc.Fields["contents"].(string),
				Tags:        doc.Fields["tags"].(string),
				Author:      doc.Fields["author"].(string),
			}
			spells = append(spells, spell)
		}
		index.Close()

		c.JSON(http.StatusOK, spells)
		return
	}

	log.Print("Getting all spells")

	var spells []Spell.Spell
	searchResult, err := Spell.GetAllSpells(index)
	index.Close()
	for _, doc := range searchResult.Hits {
		spell := Spell.Spell{
			ID:          doc.Fields["id"].(string),
			Description: doc.Fields["description"].(string),
			Language:    doc.Fields["language"].(string),
			Contents:    doc.Fields["contents"].(string),
			Tags:        doc.Fields["tags"].(string),
			Author:      doc.Fields["author"].(string),
		}
		spells = append(spells, spell)
	}
	if err != nil {
		panic(err)
	}
	c.JSON(http.StatusOK, spells)
}

func ping(c *gin.Context) {
	ping := Utils.SpellbookPing{
		Version: "1.0",
	}

	c.JSON(http.StatusOK, ping)
}
